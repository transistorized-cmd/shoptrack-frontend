import { ref, readonly } from "vue";
import { SECURITY, TIMEOUT } from "@/constants/app";

interface CsrfTokenState {
  token: string;
  expires: number;
  isCompromised?: boolean;
}

interface BackendCsrfResponse {
  token: string;
  expiresAt: string;
  expiresIn: number;
}

class CsrfTokenManager {
  private static instance: CsrfTokenManager;
  private tokenState = ref<CsrfTokenState | null>(null);
  private refreshPromise: Promise<string> | null = null;

  private constructor() {}

  static getInstance(): CsrfTokenManager {
    if (!CsrfTokenManager.instance) {
      CsrfTokenManager.instance = new CsrfTokenManager();
    }
    return CsrfTokenManager.instance;
  }

  /**
   * Helper function to build API base URL from environment variables
   * This matches the logic in api.ts to ensure consistent session handling
   */
  private getApiBaseURL(): string {
    // In development, use relative URLs to go through Vite proxy
    if (import.meta.env.MODE === "development") {
      return "/api";
    }

    // Use full URL if provided
    if (import.meta.env.VITE_API_URL) {
      return import.meta.env.VITE_API_URL;
    }

    // Build URL from components for production
    const protocol = import.meta.env.VITE_API_PROTOCOL || "https";
    const host = import.meta.env.VITE_API_HOST || "localhost";
    const port = import.meta.env.VITE_API_PORT || "5298";

    return `${protocol}://${host}:${port}/api`;
  }

  /**
   * Fetch CSRF token from backend API
   */
  private async fetchTokenFromBackend(): Promise<BackendCsrfResponse> {
    const baseUrl = this.getApiBaseURL();
    const url = `${baseUrl}/security/csrf-token`;
    console.log('[CSRF Manager] Fetching CSRF token from:', url);

    const response = await fetch(url, {
      method: "GET",
      credentials: "include", // Include session cookies
      headers: {
        Accept: "application/json",
        "Content-Type": "application/json",
      },
    });

    console.log('[CSRF Manager] Response status:', response.status, response.statusText);

    if (!response.ok) {
      const errorText = await response.text();
      console.error('[CSRF Manager] Failed to fetch CSRF token:', response.status, errorText);
      throw new Error(
        `Failed to fetch CSRF token: ${response.status} ${response.statusText}`,
      );
    }

    const result = await response.json();
    console.log('[CSRF Manager] Successfully fetched CSRF token:', result.token?.substring(0, 20) + '...');
    return result;
  }

  /**
   * Check if current token is valid and not expired
   */
  private isTokenValid(): boolean {
    if (!this.tokenState.value) return false;
    if (this.tokenState.value.isCompromised) return false;
    return Date.now() < this.tokenState.value.expires - TIMEOUT.CSRF_BUFFER;
  }

  /**
   * Check if a token appears to be client-side generated (weaker security)
   * Server tokens typically have different patterns or prefixes
   */
  private isClientSideToken(token: string): boolean {
    // This is a simple heuristic - in a real implementation,
    // server tokens might have specific prefixes or patterns
    // For now, assume tokens generated by our fallback method are client-side
    return token.length === SECURITY.CSRF_TOKEN_LENGTH * 2; // hex encoding doubles length
  }

  /**
   * Refresh the CSRF token from backend
   */
  private async refreshToken(): Promise<string> {
    // If already refreshing, return the existing promise
    if (this.refreshPromise) {
      return this.refreshPromise;
    }

    this.refreshPromise = (async () => {
      try {
        console.debug("Fetching CSRF token from backend...");

        // Fetch token from backend
        const backendResponse = await this.fetchTokenFromBackend();
        const expires = new Date(backendResponse.expiresAt).getTime();

        this.tokenState.value = {
          token: backendResponse.token,
          expires,
        };

        // Store in sessionStorage for persistence across page reloads
        sessionStorage.setItem(
          "csrf_token",
          JSON.stringify(this.tokenState.value),
        );

        console.info("CSRF token fetched from backend successfully");
        return backendResponse.token;
      } catch (error) {
        console.error("Failed to fetch CSRF token from backend:", error);

        // Try to use stored token as fallback (only if it's server-generated)
        const stored = this.loadFromStorage();
        if (
          stored &&
          stored.expires > Date.now() &&
          !this.isClientSideToken(stored.token)
        ) {
          this.tokenState.value = stored;
          console.warn("Using stored server-generated CSRF token as fallback");
          return stored.token;
        }

        // Fail gracefully instead of generating weak client-side token
        console.error(
          "CSRF token unavailable - backend unreachable and no valid stored token",
        );

        // Set a flag to indicate CSRF protection is compromised
        this.tokenState.value = {
          token: "",
          expires: 0,
          isCompromised: true,
        };

        // Throw error to indicate CSRF protection failure
        throw new Error(
          "CSRF protection unavailable: Cannot establish secure connection to server. Please check your connection and try again.",
        );
      } finally {
        this.refreshPromise = null;
      }
    })();

    return this.refreshPromise;
  }

  /**
   * Load token from storage
   */
  private loadFromStorage(): CsrfTokenState | null {
    try {
      const stored = sessionStorage.getItem("csrf_token");
      if (stored) {
        return JSON.parse(stored) as CsrfTokenState;
      }
    } catch (error) {
      console.warn("Failed to load CSRF token from storage:", error);
    }
    return null;
  }

  /**
   * Initialize token from storage or fetch new one
   */
  private async initializeToken(): Promise<void> {
    try {
      // Try to restore from sessionStorage
      const stored = this.loadFromStorage();
      if (stored && stored.expires > Date.now() + 60000) {
        // Must have >1 min remaining
        // Validate the stored token with the backend to ensure session is still valid
        console.debug("CSRF token found in storage, validating with backend...");
        const isValid = await this.validateToken(stored.token);
        if (isValid) {
          this.tokenState.value = stored;
          console.debug("CSRF token restored from storage and validated");
          return;
        } else {
          console.warn("Stored CSRF token is invalid (session expired or server restarted), fetching new token");
          sessionStorage.removeItem('csrf_token');
        }
      }
    } catch (error) {
      console.warn("Failed to restore CSRF token from storage:", error);
      sessionStorage.removeItem('csrf_token');
    }

    // Fetch new token from backend if none exists or expired
    await this.refreshToken();
  }

  /**
   * Get current valid CSRF token
   */
  async getToken(): Promise<string> {
    if (!this.isTokenValid()) {
      try {
        await this.refreshToken();
      } catch (error) {
        // If CSRF token refresh fails, propagate the error
        // This ensures that API calls fail fast rather than proceeding without proper protection
        throw error;
      }
    }

    if (this.tokenState.value?.isCompromised) {
      throw new Error(
        "CSRF protection is compromised - cannot proceed with request",
      );
    }

    return this.tokenState.value?.token || "";
  }

  /**
   * Get reactive token state (for Vue components)
   */
  getTokenState() {
    return readonly(this.tokenState);
  }

  /**
   * Invalidate current token (e.g., on logout)
   */
  invalidateToken(): void {
    this.tokenState.value = null;
    sessionStorage.removeItem("csrf_token");
  }

  /**
   * Check if CSRF protection is currently available
   * Useful for UI components to show warnings when protection is compromised
   */
  isCsrfProtectionAvailable(): boolean {
    return (
      this.tokenState.value !== null &&
      !this.tokenState.value.isCompromised &&
      this.isTokenValid()
    );
  }

  /**
   * Validate token with backend
   */
  async validateToken(token?: string): Promise<boolean> {
    try {
      const tokenToValidate = token || this.tokenState.value?.token;
      if (!tokenToValidate) return false;

      const baseUrl = this.getApiBaseURL();
      const response = await fetch(`${baseUrl}/security/validate-csrf-token`, {
        method: "POST",
        credentials: "include",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ token: tokenToValidate }),
      });

      if (response.ok) {
        const result = await response.json();

        // Update token if backend provided a refreshed one
        if (result.refreshedToken) {
          const expires = new Date(result.expiresAt).getTime();
          this.tokenState.value = {
            token: result.refreshedToken,
            expires,
          };
          sessionStorage.setItem(
            "csrf_token",
            JSON.stringify(this.tokenState.value),
          );
          console.info("CSRF token refreshed by validation endpoint");
        }

        return result.isValid;
      }

      return false;
    } catch (error) {
      console.error("Failed to validate CSRF token:", error);
      return false;
    }
  }

  /**
   * Initialize the token manager
   */
  async initialize(): Promise<void> {
    await this.initializeToken();
  }
}

// Singleton instance
const csrfManager = CsrfTokenManager.getInstance();

/**
 * Composable for CSRF token management
 */
export function useCsrfToken() {
  const tokenState = csrfManager.getTokenState();

  /**
   * Get current CSRF token, fetching from backend if needed
   */
  const getCsrfToken = async (): Promise<string> => {
    return csrfManager.getToken();
  };

  /**
   * Get CSRF token synchronously (may be empty if not loaded)
   */
  const getCsrfTokenSync = (): string => {
    return tokenState.value?.token || "";
  };

  /**
   * Initialize CSRF token management
   */
  const initializeCsrf = async (): Promise<void> => {
    await csrfManager.initialize();
  };

  /**
   * Invalidate current token
   */
  const invalidateCsrf = (): void => {
    csrfManager.invalidateToken();
  };

  /**
   * Check if token is currently valid
   */
  const isTokenValid = (): boolean => {
    if (!tokenState.value) return false;
    return Date.now() < tokenState.value.expires - TIMEOUT.CSRF_BUFFER;
  };

  /**
   * Get token expiry time
   */
  const getTokenExpiry = (): Date | null => {
    return tokenState.value ? new Date(tokenState.value.expires) : null;
  };

  /**
   * Check if CSRF protection is available
   */
  const isCsrfProtectionAvailable = (): boolean => {
    return csrfManager.isCsrfProtectionAvailable();
  };

  /**
   * Validate token with backend
   */
  const validateCsrfToken = async (token?: string): Promise<boolean> => {
    return csrfManager.validateToken(token);
  };

  return {
    // Reactive state
    tokenState: readonly(tokenState),

    // Methods
    getCsrfToken,
    getCsrfTokenSync,
    initializeCsrf,
    invalidateCsrf,
    isTokenValid,
    getTokenExpiry,
    validateCsrfToken,
    isCsrfProtectionAvailable,
  };
}

// Export the manager instance for direct use in services
export { csrfManager };
